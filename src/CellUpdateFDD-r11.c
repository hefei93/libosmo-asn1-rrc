/*
 * Generated by asn1c-0.9.24 (http://lionet.info/asn1c)
 * From ASN.1 module "PDU-definitions"
 * 	found in "../asn/PDU-definitions.asn"
 * 	`asn1c -fcompound-names -fnative-types`
 */

#include "CellUpdateFDD-r11.h"

static int
trafficVolumeIndicator_10_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
trafficVolumeIndicator_10_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
trafficVolumeIndicator_10_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	trafficVolumeIndicator_10_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
trafficVolumeIndicator_10_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	trafficVolumeIndicator_10_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
trafficVolumeIndicator_10_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	trafficVolumeIndicator_10_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
trafficVolumeIndicator_10_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	trafficVolumeIndicator_10_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
trafficVolumeIndicator_10_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	trafficVolumeIndicator_10_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
trafficVolumeIndicator_10_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	trafficVolumeIndicator_10_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
trafficVolumeIndicator_10_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	trafficVolumeIndicator_10_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
trafficVolumeIndicator_10_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	trafficVolumeIndicator_10_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
reconfigurationStatusIndicator_12_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
reconfigurationStatusIndicator_12_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
reconfigurationStatusIndicator_12_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	reconfigurationStatusIndicator_12_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
reconfigurationStatusIndicator_12_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	reconfigurationStatusIndicator_12_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
reconfigurationStatusIndicator_12_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	reconfigurationStatusIndicator_12_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
reconfigurationStatusIndicator_12_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	reconfigurationStatusIndicator_12_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
reconfigurationStatusIndicator_12_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	reconfigurationStatusIndicator_12_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
reconfigurationStatusIndicator_12_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	reconfigurationStatusIndicator_12_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
reconfigurationStatusIndicator_12_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	reconfigurationStatusIndicator_12_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
reconfigurationStatusIndicator_12_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	reconfigurationStatusIndicator_12_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
csCallType_14_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
csCallType_14_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
csCallType_14_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	csCallType_14_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
csCallType_14_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	csCallType_14_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
csCallType_14_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	csCallType_14_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
csCallType_14_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	csCallType_14_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
csCallType_14_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	csCallType_14_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
csCallType_14_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	csCallType_14_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
csCallType_14_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	csCallType_14_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
csCallType_14_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	csCallType_14_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
hspdschReception_CellFach_19_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
hspdschReception_CellFach_19_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
hspdschReception_CellFach_19_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	hspdschReception_CellFach_19_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
hspdschReception_CellFach_19_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	hspdschReception_CellFach_19_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
hspdschReception_CellFach_19_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	hspdschReception_CellFach_19_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
hspdschReception_CellFach_19_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	hspdschReception_CellFach_19_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
hspdschReception_CellFach_19_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	hspdschReception_CellFach_19_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
hspdschReception_CellFach_19_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	hspdschReception_CellFach_19_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
hspdschReception_CellFach_19_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	hspdschReception_CellFach_19_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
hspdschReception_CellFach_19_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	hspdschReception_CellFach_19_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
capabilityChangeIndicator_22_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
capabilityChangeIndicator_22_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
capabilityChangeIndicator_22_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	capabilityChangeIndicator_22_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
capabilityChangeIndicator_22_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	capabilityChangeIndicator_22_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
capabilityChangeIndicator_22_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	capabilityChangeIndicator_22_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
capabilityChangeIndicator_22_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	capabilityChangeIndicator_22_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
capabilityChangeIndicator_22_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	capabilityChangeIndicator_22_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
capabilityChangeIndicator_22_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	capabilityChangeIndicator_22_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
capabilityChangeIndicator_22_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	capabilityChangeIndicator_22_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
capabilityChangeIndicator_22_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	capabilityChangeIndicator_22_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
supportOfCommonEDCH_24_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
supportOfCommonEDCH_24_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
supportOfCommonEDCH_24_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	supportOfCommonEDCH_24_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
supportOfCommonEDCH_24_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	supportOfCommonEDCH_24_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
supportOfCommonEDCH_24_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	supportOfCommonEDCH_24_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
supportOfCommonEDCH_24_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	supportOfCommonEDCH_24_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
supportOfCommonEDCH_24_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	supportOfCommonEDCH_24_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
supportOfCommonEDCH_24_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	supportOfCommonEDCH_24_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
supportOfCommonEDCH_24_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	supportOfCommonEDCH_24_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
supportOfCommonEDCH_24_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	supportOfCommonEDCH_24_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
supportOfHS_DSCHDRXOperation_26_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
supportOfHS_DSCHDRXOperation_26_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
supportOfHS_DSCHDRXOperation_26_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	supportOfHS_DSCHDRXOperation_26_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
supportOfHS_DSCHDRXOperation_26_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	supportOfHS_DSCHDRXOperation_26_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
supportOfHS_DSCHDRXOperation_26_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	supportOfHS_DSCHDRXOperation_26_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
supportOfHS_DSCHDRXOperation_26_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	supportOfHS_DSCHDRXOperation_26_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
supportOfHS_DSCHDRXOperation_26_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	supportOfHS_DSCHDRXOperation_26_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
supportOfHS_DSCHDRXOperation_26_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	supportOfHS_DSCHDRXOperation_26_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
supportOfHS_DSCHDRXOperation_26_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	supportOfHS_DSCHDRXOperation_26_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
supportOfHS_DSCHDRXOperation_26_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	supportOfHS_DSCHDRXOperation_26_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
supportOfMACiis_28_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
supportOfMACiis_28_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
supportOfMACiis_28_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	supportOfMACiis_28_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
supportOfMACiis_28_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	supportOfMACiis_28_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
supportOfMACiis_28_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	supportOfMACiis_28_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
supportOfMACiis_28_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	supportOfMACiis_28_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
supportOfMACiis_28_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	supportOfMACiis_28_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
supportOfMACiis_28_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	supportOfMACiis_28_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
supportOfMACiis_28_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	supportOfMACiis_28_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
supportOfMACiis_28_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	supportOfMACiis_28_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
securityRevertStatusIndicator_30_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
securityRevertStatusIndicator_30_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
securityRevertStatusIndicator_30_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	securityRevertStatusIndicator_30_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
securityRevertStatusIndicator_30_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	securityRevertStatusIndicator_30_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
securityRevertStatusIndicator_30_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	securityRevertStatusIndicator_30_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
securityRevertStatusIndicator_30_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	securityRevertStatusIndicator_30_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
securityRevertStatusIndicator_30_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	securityRevertStatusIndicator_30_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
securityRevertStatusIndicator_30_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	securityRevertStatusIndicator_30_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
securityRevertStatusIndicator_30_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	securityRevertStatusIndicator_30_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
securityRevertStatusIndicator_30_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	securityRevertStatusIndicator_30_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
spare4_33_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
spare4_33_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
spare4_33_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	spare4_33_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
spare4_33_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	spare4_33_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
spare4_33_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	spare4_33_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
spare4_33_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	spare4_33_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
spare4_33_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	spare4_33_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
spare4_33_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	spare4_33_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
spare4_33_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	spare4_33_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
spare4_33_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	spare4_33_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
spare3_35_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
spare3_35_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
spare3_35_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	spare3_35_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
spare3_35_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	spare3_35_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
spare3_35_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	spare3_35_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
spare3_35_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	spare3_35_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
spare3_35_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	spare3_35_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
spare3_35_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	spare3_35_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
spare3_35_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	spare3_35_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
spare3_35_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	spare3_35_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
spare2_37_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
spare2_37_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
spare2_37_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	spare2_37_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
spare2_37_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	spare2_37_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
spare2_37_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	spare2_37_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
spare2_37_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	spare2_37_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
spare2_37_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	spare2_37_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
spare2_37_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	spare2_37_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
spare2_37_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	spare2_37_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
spare2_37_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	spare2_37_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
spare1_39_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
spare1_39_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
spare1_39_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	spare1_39_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
spare1_39_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	spare1_39_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
spare1_39_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	spare1_39_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
spare1_39_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	spare1_39_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
spare1_39_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	spare1_39_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
spare1_39_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	spare1_39_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
spare1_39_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	spare1_39_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
spare1_39_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	spare1_39_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
loggedMeasAvailable_42_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
loggedMeasAvailable_42_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
loggedMeasAvailable_42_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	loggedMeasAvailable_42_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
loggedMeasAvailable_42_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	loggedMeasAvailable_42_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
loggedMeasAvailable_42_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	loggedMeasAvailable_42_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
loggedMeasAvailable_42_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	loggedMeasAvailable_42_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
loggedMeasAvailable_42_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	loggedMeasAvailable_42_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
loggedMeasAvailable_42_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	loggedMeasAvailable_42_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
loggedMeasAvailable_42_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	loggedMeasAvailable_42_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
loggedMeasAvailable_42_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	loggedMeasAvailable_42_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static int
loggedANRResultsAvailable_44_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_NativeEnumerated.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static void
loggedANRResultsAvailable_44_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}

static void
loggedANRResultsAvailable_44_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	loggedANRResultsAvailable_44_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

static int
loggedANRResultsAvailable_44_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	loggedANRResultsAvailable_44_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

static asn_dec_rval_t
loggedANRResultsAvailable_44_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	loggedANRResultsAvailable_44_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

static asn_enc_rval_t
loggedANRResultsAvailable_44_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	loggedANRResultsAvailable_44_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

static asn_dec_rval_t
loggedANRResultsAvailable_44_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	loggedANRResultsAvailable_44_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

static asn_enc_rval_t
loggedANRResultsAvailable_44_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	loggedANRResultsAvailable_44_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}

static asn_dec_rval_t
loggedANRResultsAvailable_44_decode_uper(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints, void **structure, asn_per_data_t *per_data) {
	loggedANRResultsAvailable_44_inherit_TYPE_descriptor(td);
	return td->uper_decoder(opt_codec_ctx, td, constraints, structure, per_data);
}

static asn_enc_rval_t
loggedANRResultsAvailable_44_encode_uper(asn_TYPE_descriptor_t *td,
		asn_per_constraints_t *constraints,
		void *structure, asn_per_outp_t *per_out) {
	loggedANRResultsAvailable_44_inherit_TYPE_descriptor(td);
	return td->uper_encoder(td, constraints, structure, per_out);
}

static asn_per_constraints_t asn_PER_type_trafficVolumeIndicator_constr_10 = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_reconfigurationStatusIndicator_constr_12 = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_csCallType_constr_14 = {
	{ APC_CONSTRAINED,	 2,  2,  0,  3 }	/* (0..3) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_hspdschReception_CellFach_constr_19 = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_capabilityChangeIndicator_constr_22 = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_supportOfCommonEDCH_constr_24 = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_supportOfHS_DSCHDRXOperation_constr_26 = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_supportOfMACiis_constr_28 = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_securityRevertStatusIndicator_constr_30 = {
	{ APC_CONSTRAINED,	 1,  1,  0,  1 }	/* (0..1) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_spare4_constr_33 = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_spare3_constr_35 = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_spare2_constr_37 = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_spare1_constr_39 = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_loggedMeasAvailable_constr_42 = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_type_loggedANRResultsAvailable_constr_44 = {
	{ APC_CONSTRAINED,	 0,  0,  0,  0 }	/* (0..0) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_INTEGER_enum_map_t asn_MAP_trafficVolumeIndicator_value2enum_10[] = {
	{ 0,	4,	"true" }
};
static unsigned int asn_MAP_trafficVolumeIndicator_enum2value_10[] = {
	0	/* true(0) */
};
static asn_INTEGER_specifics_t asn_SPC_trafficVolumeIndicator_specs_10 = {
	asn_MAP_trafficVolumeIndicator_value2enum_10,	/* "tag" => N; sorted by tag */
	asn_MAP_trafficVolumeIndicator_enum2value_10,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_trafficVolumeIndicator_tags_10[] = {
	(ASN_TAG_CLASS_CONTEXT | (8 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_trafficVolumeIndicator_10 = {
	"trafficVolumeIndicator",
	"trafficVolumeIndicator",
	trafficVolumeIndicator_10_free,
	trafficVolumeIndicator_10_print,
	trafficVolumeIndicator_10_constraint,
	trafficVolumeIndicator_10_decode_ber,
	trafficVolumeIndicator_10_encode_der,
	trafficVolumeIndicator_10_decode_xer,
	trafficVolumeIndicator_10_encode_xer,
	trafficVolumeIndicator_10_decode_uper,
	trafficVolumeIndicator_10_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_trafficVolumeIndicator_tags_10,
	sizeof(asn_DEF_trafficVolumeIndicator_tags_10)
		/sizeof(asn_DEF_trafficVolumeIndicator_tags_10[0]) - 1, /* 1 */
	asn_DEF_trafficVolumeIndicator_tags_10,	/* Same as above */
	sizeof(asn_DEF_trafficVolumeIndicator_tags_10)
		/sizeof(asn_DEF_trafficVolumeIndicator_tags_10[0]), /* 2 */
	&asn_PER_type_trafficVolumeIndicator_constr_10,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_trafficVolumeIndicator_specs_10	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_reconfigurationStatusIndicator_value2enum_12[] = {
	{ 0,	4,	"true" }
};
static unsigned int asn_MAP_reconfigurationStatusIndicator_enum2value_12[] = {
	0	/* true(0) */
};
static asn_INTEGER_specifics_t asn_SPC_reconfigurationStatusIndicator_specs_12 = {
	asn_MAP_reconfigurationStatusIndicator_value2enum_12,	/* "tag" => N; sorted by tag */
	asn_MAP_reconfigurationStatusIndicator_enum2value_12,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_reconfigurationStatusIndicator_tags_12[] = {
	(ASN_TAG_CLASS_CONTEXT | (9 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_reconfigurationStatusIndicator_12 = {
	"reconfigurationStatusIndicator",
	"reconfigurationStatusIndicator",
	reconfigurationStatusIndicator_12_free,
	reconfigurationStatusIndicator_12_print,
	reconfigurationStatusIndicator_12_constraint,
	reconfigurationStatusIndicator_12_decode_ber,
	reconfigurationStatusIndicator_12_encode_der,
	reconfigurationStatusIndicator_12_decode_xer,
	reconfigurationStatusIndicator_12_encode_xer,
	reconfigurationStatusIndicator_12_decode_uper,
	reconfigurationStatusIndicator_12_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_reconfigurationStatusIndicator_tags_12,
	sizeof(asn_DEF_reconfigurationStatusIndicator_tags_12)
		/sizeof(asn_DEF_reconfigurationStatusIndicator_tags_12[0]) - 1, /* 1 */
	asn_DEF_reconfigurationStatusIndicator_tags_12,	/* Same as above */
	sizeof(asn_DEF_reconfigurationStatusIndicator_tags_12)
		/sizeof(asn_DEF_reconfigurationStatusIndicator_tags_12[0]), /* 2 */
	&asn_PER_type_reconfigurationStatusIndicator_constr_12,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_reconfigurationStatusIndicator_specs_12	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_csCallType_value2enum_14[] = {
	{ 0,	6,	"speech" },
	{ 1,	5,	"video" },
	{ 2,	5,	"other" },
	{ 3,	5,	"spare" }
};
static unsigned int asn_MAP_csCallType_enum2value_14[] = {
	2,	/* other(2) */
	3,	/* spare(3) */
	0,	/* speech(0) */
	1	/* video(1) */
};
static asn_INTEGER_specifics_t asn_SPC_csCallType_specs_14 = {
	asn_MAP_csCallType_value2enum_14,	/* "tag" => N; sorted by tag */
	asn_MAP_csCallType_enum2value_14,	/* N => "tag"; sorted by N */
	4,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_csCallType_tags_14[] = {
	(ASN_TAG_CLASS_CONTEXT | (10 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_csCallType_14 = {
	"csCallType",
	"csCallType",
	csCallType_14_free,
	csCallType_14_print,
	csCallType_14_constraint,
	csCallType_14_decode_ber,
	csCallType_14_encode_der,
	csCallType_14_decode_xer,
	csCallType_14_encode_xer,
	csCallType_14_decode_uper,
	csCallType_14_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_csCallType_tags_14,
	sizeof(asn_DEF_csCallType_tags_14)
		/sizeof(asn_DEF_csCallType_tags_14[0]) - 1, /* 1 */
	asn_DEF_csCallType_tags_14,	/* Same as above */
	sizeof(asn_DEF_csCallType_tags_14)
		/sizeof(asn_DEF_csCallType_tags_14[0]), /* 2 */
	&asn_PER_type_csCallType_constr_14,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_csCallType_specs_14	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_hspdschReception_CellFach_value2enum_19[] = {
	{ 0,	4,	"true" }
};
static unsigned int asn_MAP_hspdschReception_CellFach_enum2value_19[] = {
	0	/* true(0) */
};
static asn_INTEGER_specifics_t asn_SPC_hspdschReception_CellFach_specs_19 = {
	asn_MAP_hspdschReception_CellFach_value2enum_19,	/* "tag" => N; sorted by tag */
	asn_MAP_hspdschReception_CellFach_enum2value_19,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_hspdschReception_CellFach_tags_19[] = {
	(ASN_TAG_CLASS_CONTEXT | (11 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_hspdschReception_CellFach_19 = {
	"hspdschReception-CellFach",
	"hspdschReception-CellFach",
	hspdschReception_CellFach_19_free,
	hspdschReception_CellFach_19_print,
	hspdschReception_CellFach_19_constraint,
	hspdschReception_CellFach_19_decode_ber,
	hspdschReception_CellFach_19_encode_der,
	hspdschReception_CellFach_19_decode_xer,
	hspdschReception_CellFach_19_encode_xer,
	hspdschReception_CellFach_19_decode_uper,
	hspdschReception_CellFach_19_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_hspdschReception_CellFach_tags_19,
	sizeof(asn_DEF_hspdschReception_CellFach_tags_19)
		/sizeof(asn_DEF_hspdschReception_CellFach_tags_19[0]) - 1, /* 1 */
	asn_DEF_hspdschReception_CellFach_tags_19,	/* Same as above */
	sizeof(asn_DEF_hspdschReception_CellFach_tags_19)
		/sizeof(asn_DEF_hspdschReception_CellFach_tags_19[0]), /* 2 */
	&asn_PER_type_hspdschReception_CellFach_constr_19,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_hspdschReception_CellFach_specs_19	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_capabilityChangeIndicator_value2enum_22[] = {
	{ 0,	4,	"true" }
};
static unsigned int asn_MAP_capabilityChangeIndicator_enum2value_22[] = {
	0	/* true(0) */
};
static asn_INTEGER_specifics_t asn_SPC_capabilityChangeIndicator_specs_22 = {
	asn_MAP_capabilityChangeIndicator_value2enum_22,	/* "tag" => N; sorted by tag */
	asn_MAP_capabilityChangeIndicator_enum2value_22,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_capabilityChangeIndicator_tags_22[] = {
	(ASN_TAG_CLASS_CONTEXT | (13 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_capabilityChangeIndicator_22 = {
	"capabilityChangeIndicator",
	"capabilityChangeIndicator",
	capabilityChangeIndicator_22_free,
	capabilityChangeIndicator_22_print,
	capabilityChangeIndicator_22_constraint,
	capabilityChangeIndicator_22_decode_ber,
	capabilityChangeIndicator_22_encode_der,
	capabilityChangeIndicator_22_decode_xer,
	capabilityChangeIndicator_22_encode_xer,
	capabilityChangeIndicator_22_decode_uper,
	capabilityChangeIndicator_22_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_capabilityChangeIndicator_tags_22,
	sizeof(asn_DEF_capabilityChangeIndicator_tags_22)
		/sizeof(asn_DEF_capabilityChangeIndicator_tags_22[0]) - 1, /* 1 */
	asn_DEF_capabilityChangeIndicator_tags_22,	/* Same as above */
	sizeof(asn_DEF_capabilityChangeIndicator_tags_22)
		/sizeof(asn_DEF_capabilityChangeIndicator_tags_22[0]), /* 2 */
	&asn_PER_type_capabilityChangeIndicator_constr_22,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_capabilityChangeIndicator_specs_22	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_supportOfCommonEDCH_value2enum_24[] = {
	{ 0,	4,	"true" }
};
static unsigned int asn_MAP_supportOfCommonEDCH_enum2value_24[] = {
	0	/* true(0) */
};
static asn_INTEGER_specifics_t asn_SPC_supportOfCommonEDCH_specs_24 = {
	asn_MAP_supportOfCommonEDCH_value2enum_24,	/* "tag" => N; sorted by tag */
	asn_MAP_supportOfCommonEDCH_enum2value_24,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_supportOfCommonEDCH_tags_24[] = {
	(ASN_TAG_CLASS_CONTEXT | (14 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_supportOfCommonEDCH_24 = {
	"supportOfCommonEDCH",
	"supportOfCommonEDCH",
	supportOfCommonEDCH_24_free,
	supportOfCommonEDCH_24_print,
	supportOfCommonEDCH_24_constraint,
	supportOfCommonEDCH_24_decode_ber,
	supportOfCommonEDCH_24_encode_der,
	supportOfCommonEDCH_24_decode_xer,
	supportOfCommonEDCH_24_encode_xer,
	supportOfCommonEDCH_24_decode_uper,
	supportOfCommonEDCH_24_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_supportOfCommonEDCH_tags_24,
	sizeof(asn_DEF_supportOfCommonEDCH_tags_24)
		/sizeof(asn_DEF_supportOfCommonEDCH_tags_24[0]) - 1, /* 1 */
	asn_DEF_supportOfCommonEDCH_tags_24,	/* Same as above */
	sizeof(asn_DEF_supportOfCommonEDCH_tags_24)
		/sizeof(asn_DEF_supportOfCommonEDCH_tags_24[0]), /* 2 */
	&asn_PER_type_supportOfCommonEDCH_constr_24,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_supportOfCommonEDCH_specs_24	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_supportOfHS_DSCHDRXOperation_value2enum_26[] = {
	{ 0,	4,	"true" }
};
static unsigned int asn_MAP_supportOfHS_DSCHDRXOperation_enum2value_26[] = {
	0	/* true(0) */
};
static asn_INTEGER_specifics_t asn_SPC_supportOfHS_DSCHDRXOperation_specs_26 = {
	asn_MAP_supportOfHS_DSCHDRXOperation_value2enum_26,	/* "tag" => N; sorted by tag */
	asn_MAP_supportOfHS_DSCHDRXOperation_enum2value_26,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_supportOfHS_DSCHDRXOperation_tags_26[] = {
	(ASN_TAG_CLASS_CONTEXT | (15 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_supportOfHS_DSCHDRXOperation_26 = {
	"supportOfHS-DSCHDRXOperation",
	"supportOfHS-DSCHDRXOperation",
	supportOfHS_DSCHDRXOperation_26_free,
	supportOfHS_DSCHDRXOperation_26_print,
	supportOfHS_DSCHDRXOperation_26_constraint,
	supportOfHS_DSCHDRXOperation_26_decode_ber,
	supportOfHS_DSCHDRXOperation_26_encode_der,
	supportOfHS_DSCHDRXOperation_26_decode_xer,
	supportOfHS_DSCHDRXOperation_26_encode_xer,
	supportOfHS_DSCHDRXOperation_26_decode_uper,
	supportOfHS_DSCHDRXOperation_26_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_supportOfHS_DSCHDRXOperation_tags_26,
	sizeof(asn_DEF_supportOfHS_DSCHDRXOperation_tags_26)
		/sizeof(asn_DEF_supportOfHS_DSCHDRXOperation_tags_26[0]) - 1, /* 1 */
	asn_DEF_supportOfHS_DSCHDRXOperation_tags_26,	/* Same as above */
	sizeof(asn_DEF_supportOfHS_DSCHDRXOperation_tags_26)
		/sizeof(asn_DEF_supportOfHS_DSCHDRXOperation_tags_26[0]), /* 2 */
	&asn_PER_type_supportOfHS_DSCHDRXOperation_constr_26,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_supportOfHS_DSCHDRXOperation_specs_26	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_supportOfMACiis_value2enum_28[] = {
	{ 0,	4,	"true" }
};
static unsigned int asn_MAP_supportOfMACiis_enum2value_28[] = {
	0	/* true(0) */
};
static asn_INTEGER_specifics_t asn_SPC_supportOfMACiis_specs_28 = {
	asn_MAP_supportOfMACiis_value2enum_28,	/* "tag" => N; sorted by tag */
	asn_MAP_supportOfMACiis_enum2value_28,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_supportOfMACiis_tags_28[] = {
	(ASN_TAG_CLASS_CONTEXT | (16 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_supportOfMACiis_28 = {
	"supportOfMACiis",
	"supportOfMACiis",
	supportOfMACiis_28_free,
	supportOfMACiis_28_print,
	supportOfMACiis_28_constraint,
	supportOfMACiis_28_decode_ber,
	supportOfMACiis_28_encode_der,
	supportOfMACiis_28_decode_xer,
	supportOfMACiis_28_encode_xer,
	supportOfMACiis_28_decode_uper,
	supportOfMACiis_28_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_supportOfMACiis_tags_28,
	sizeof(asn_DEF_supportOfMACiis_tags_28)
		/sizeof(asn_DEF_supportOfMACiis_tags_28[0]) - 1, /* 1 */
	asn_DEF_supportOfMACiis_tags_28,	/* Same as above */
	sizeof(asn_DEF_supportOfMACiis_tags_28)
		/sizeof(asn_DEF_supportOfMACiis_tags_28[0]), /* 2 */
	&asn_PER_type_supportOfMACiis_constr_28,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_supportOfMACiis_specs_28	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_securityRevertStatusIndicator_value2enum_30[] = {
	{ 0,	12,	"revertedBack" },
	{ 1,	15,	"normalOperation" }
};
static unsigned int asn_MAP_securityRevertStatusIndicator_enum2value_30[] = {
	1,	/* normalOperation(1) */
	0	/* revertedBack(0) */
};
static asn_INTEGER_specifics_t asn_SPC_securityRevertStatusIndicator_specs_30 = {
	asn_MAP_securityRevertStatusIndicator_value2enum_30,	/* "tag" => N; sorted by tag */
	asn_MAP_securityRevertStatusIndicator_enum2value_30,	/* N => "tag"; sorted by N */
	2,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_securityRevertStatusIndicator_tags_30[] = {
	(ASN_TAG_CLASS_CONTEXT | (17 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_securityRevertStatusIndicator_30 = {
	"securityRevertStatusIndicator",
	"securityRevertStatusIndicator",
	securityRevertStatusIndicator_30_free,
	securityRevertStatusIndicator_30_print,
	securityRevertStatusIndicator_30_constraint,
	securityRevertStatusIndicator_30_decode_ber,
	securityRevertStatusIndicator_30_encode_der,
	securityRevertStatusIndicator_30_decode_xer,
	securityRevertStatusIndicator_30_encode_xer,
	securityRevertStatusIndicator_30_decode_uper,
	securityRevertStatusIndicator_30_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_securityRevertStatusIndicator_tags_30,
	sizeof(asn_DEF_securityRevertStatusIndicator_tags_30)
		/sizeof(asn_DEF_securityRevertStatusIndicator_tags_30[0]) - 1, /* 1 */
	asn_DEF_securityRevertStatusIndicator_tags_30,	/* Same as above */
	sizeof(asn_DEF_securityRevertStatusIndicator_tags_30)
		/sizeof(asn_DEF_securityRevertStatusIndicator_tags_30[0]), /* 2 */
	&asn_PER_type_securityRevertStatusIndicator_constr_30,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_securityRevertStatusIndicator_specs_30	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_spare4_value2enum_33[] = {
	{ 0,	4,	"true" }
};
static unsigned int asn_MAP_spare4_enum2value_33[] = {
	0	/* true(0) */
};
static asn_INTEGER_specifics_t asn_SPC_spare4_specs_33 = {
	asn_MAP_spare4_value2enum_33,	/* "tag" => N; sorted by tag */
	asn_MAP_spare4_enum2value_33,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_spare4_tags_33[] = {
	(ASN_TAG_CLASS_CONTEXT | (18 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_spare4_33 = {
	"spare4",
	"spare4",
	spare4_33_free,
	spare4_33_print,
	spare4_33_constraint,
	spare4_33_decode_ber,
	spare4_33_encode_der,
	spare4_33_decode_xer,
	spare4_33_encode_xer,
	spare4_33_decode_uper,
	spare4_33_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_spare4_tags_33,
	sizeof(asn_DEF_spare4_tags_33)
		/sizeof(asn_DEF_spare4_tags_33[0]) - 1, /* 1 */
	asn_DEF_spare4_tags_33,	/* Same as above */
	sizeof(asn_DEF_spare4_tags_33)
		/sizeof(asn_DEF_spare4_tags_33[0]), /* 2 */
	&asn_PER_type_spare4_constr_33,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_spare4_specs_33	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_spare3_value2enum_35[] = {
	{ 0,	4,	"true" }
};
static unsigned int asn_MAP_spare3_enum2value_35[] = {
	0	/* true(0) */
};
static asn_INTEGER_specifics_t asn_SPC_spare3_specs_35 = {
	asn_MAP_spare3_value2enum_35,	/* "tag" => N; sorted by tag */
	asn_MAP_spare3_enum2value_35,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_spare3_tags_35[] = {
	(ASN_TAG_CLASS_CONTEXT | (19 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_spare3_35 = {
	"spare3",
	"spare3",
	spare3_35_free,
	spare3_35_print,
	spare3_35_constraint,
	spare3_35_decode_ber,
	spare3_35_encode_der,
	spare3_35_decode_xer,
	spare3_35_encode_xer,
	spare3_35_decode_uper,
	spare3_35_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_spare3_tags_35,
	sizeof(asn_DEF_spare3_tags_35)
		/sizeof(asn_DEF_spare3_tags_35[0]) - 1, /* 1 */
	asn_DEF_spare3_tags_35,	/* Same as above */
	sizeof(asn_DEF_spare3_tags_35)
		/sizeof(asn_DEF_spare3_tags_35[0]), /* 2 */
	&asn_PER_type_spare3_constr_35,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_spare3_specs_35	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_spare2_value2enum_37[] = {
	{ 0,	4,	"true" }
};
static unsigned int asn_MAP_spare2_enum2value_37[] = {
	0	/* true(0) */
};
static asn_INTEGER_specifics_t asn_SPC_spare2_specs_37 = {
	asn_MAP_spare2_value2enum_37,	/* "tag" => N; sorted by tag */
	asn_MAP_spare2_enum2value_37,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_spare2_tags_37[] = {
	(ASN_TAG_CLASS_CONTEXT | (20 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_spare2_37 = {
	"spare2",
	"spare2",
	spare2_37_free,
	spare2_37_print,
	spare2_37_constraint,
	spare2_37_decode_ber,
	spare2_37_encode_der,
	spare2_37_decode_xer,
	spare2_37_encode_xer,
	spare2_37_decode_uper,
	spare2_37_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_spare2_tags_37,
	sizeof(asn_DEF_spare2_tags_37)
		/sizeof(asn_DEF_spare2_tags_37[0]) - 1, /* 1 */
	asn_DEF_spare2_tags_37,	/* Same as above */
	sizeof(asn_DEF_spare2_tags_37)
		/sizeof(asn_DEF_spare2_tags_37[0]), /* 2 */
	&asn_PER_type_spare2_constr_37,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_spare2_specs_37	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_spare1_value2enum_39[] = {
	{ 0,	4,	"true" }
};
static unsigned int asn_MAP_spare1_enum2value_39[] = {
	0	/* true(0) */
};
static asn_INTEGER_specifics_t asn_SPC_spare1_specs_39 = {
	asn_MAP_spare1_value2enum_39,	/* "tag" => N; sorted by tag */
	asn_MAP_spare1_enum2value_39,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_spare1_tags_39[] = {
	(ASN_TAG_CLASS_CONTEXT | (21 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_spare1_39 = {
	"spare1",
	"spare1",
	spare1_39_free,
	spare1_39_print,
	spare1_39_constraint,
	spare1_39_decode_ber,
	spare1_39_encode_der,
	spare1_39_decode_xer,
	spare1_39_encode_xer,
	spare1_39_decode_uper,
	spare1_39_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_spare1_tags_39,
	sizeof(asn_DEF_spare1_tags_39)
		/sizeof(asn_DEF_spare1_tags_39[0]) - 1, /* 1 */
	asn_DEF_spare1_tags_39,	/* Same as above */
	sizeof(asn_DEF_spare1_tags_39)
		/sizeof(asn_DEF_spare1_tags_39[0]), /* 2 */
	&asn_PER_type_spare1_constr_39,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_spare1_specs_39	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_loggedMeasAvailable_value2enum_42[] = {
	{ 0,	4,	"true" }
};
static unsigned int asn_MAP_loggedMeasAvailable_enum2value_42[] = {
	0	/* true(0) */
};
static asn_INTEGER_specifics_t asn_SPC_loggedMeasAvailable_specs_42 = {
	asn_MAP_loggedMeasAvailable_value2enum_42,	/* "tag" => N; sorted by tag */
	asn_MAP_loggedMeasAvailable_enum2value_42,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_loggedMeasAvailable_tags_42[] = {
	(ASN_TAG_CLASS_CONTEXT | (23 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_loggedMeasAvailable_42 = {
	"loggedMeasAvailable",
	"loggedMeasAvailable",
	loggedMeasAvailable_42_free,
	loggedMeasAvailable_42_print,
	loggedMeasAvailable_42_constraint,
	loggedMeasAvailable_42_decode_ber,
	loggedMeasAvailable_42_encode_der,
	loggedMeasAvailable_42_decode_xer,
	loggedMeasAvailable_42_encode_xer,
	loggedMeasAvailable_42_decode_uper,
	loggedMeasAvailable_42_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_loggedMeasAvailable_tags_42,
	sizeof(asn_DEF_loggedMeasAvailable_tags_42)
		/sizeof(asn_DEF_loggedMeasAvailable_tags_42[0]) - 1, /* 1 */
	asn_DEF_loggedMeasAvailable_tags_42,	/* Same as above */
	sizeof(asn_DEF_loggedMeasAvailable_tags_42)
		/sizeof(asn_DEF_loggedMeasAvailable_tags_42[0]), /* 2 */
	&asn_PER_type_loggedMeasAvailable_constr_42,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_loggedMeasAvailable_specs_42	/* Additional specs */
};

static asn_INTEGER_enum_map_t asn_MAP_loggedANRResultsAvailable_value2enum_44[] = {
	{ 0,	4,	"true" }
};
static unsigned int asn_MAP_loggedANRResultsAvailable_enum2value_44[] = {
	0	/* true(0) */
};
static asn_INTEGER_specifics_t asn_SPC_loggedANRResultsAvailable_specs_44 = {
	asn_MAP_loggedANRResultsAvailable_value2enum_44,	/* "tag" => N; sorted by tag */
	asn_MAP_loggedANRResultsAvailable_enum2value_44,	/* N => "tag"; sorted by N */
	1,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static ber_tlv_tag_t asn_DEF_loggedANRResultsAvailable_tags_44[] = {
	(ASN_TAG_CLASS_CONTEXT | (24 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_loggedANRResultsAvailable_44 = {
	"loggedANRResultsAvailable",
	"loggedANRResultsAvailable",
	loggedANRResultsAvailable_44_free,
	loggedANRResultsAvailable_44_print,
	loggedANRResultsAvailable_44_constraint,
	loggedANRResultsAvailable_44_decode_ber,
	loggedANRResultsAvailable_44_encode_der,
	loggedANRResultsAvailable_44_decode_xer,
	loggedANRResultsAvailable_44_encode_xer,
	loggedANRResultsAvailable_44_decode_uper,
	loggedANRResultsAvailable_44_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_loggedANRResultsAvailable_tags_44,
	sizeof(asn_DEF_loggedANRResultsAvailable_tags_44)
		/sizeof(asn_DEF_loggedANRResultsAvailable_tags_44[0]) - 1, /* 1 */
	asn_DEF_loggedANRResultsAvailable_tags_44,	/* Same as above */
	sizeof(asn_DEF_loggedANRResultsAvailable_tags_44)
		/sizeof(asn_DEF_loggedANRResultsAvailable_tags_44[0]), /* 2 */
	&asn_PER_type_loggedANRResultsAvailable_constr_44,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_loggedANRResultsAvailable_specs_44	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_CellUpdateFDD_r11_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct CellUpdateFDD_r11, u_RNTI),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_U_RNTI,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"u-RNTI"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct CellUpdateFDD_r11, startList),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_STARTList,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"startList"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct CellUpdateFDD_r11, am_RLC_ErrorIndicationRb2_3or4),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BOOLEAN,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"am-RLC-ErrorIndicationRb2-3or4"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct CellUpdateFDD_r11, am_RLC_ErrorIndicationRb5orAbove),
		(ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_BOOLEAN,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"am-RLC-ErrorIndicationRb5orAbove"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct CellUpdateFDD_r11, cellUpdateCause),
		(ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_CellUpdateCause,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"cellUpdateCause"
		},
	{ ATF_POINTER, 1, offsetof(struct CellUpdateFDD_r11, failureCause),
		(ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_FailureCauseWithProtErrTrId,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"failureCause"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct CellUpdateFDD_r11, rb_timer_indicator),
		(ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Rb_timer_indicator,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"rb-timer-indicator"
		},
	{ ATF_POINTER, 18, offsetof(struct CellUpdateFDD_r11, establishmentCause),
		(ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_EstablishmentCause,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"establishmentCause"
		},
	{ ATF_POINTER, 17, offsetof(struct CellUpdateFDD_r11, trafficVolumeIndicator),
		(ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_trafficVolumeIndicator_10,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"trafficVolumeIndicator"
		},
	{ ATF_POINTER, 16, offsetof(struct CellUpdateFDD_r11, reconfigurationStatusIndicator),
		(ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_reconfigurationStatusIndicator_12,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"reconfigurationStatusIndicator"
		},
	{ ATF_POINTER, 15, offsetof(struct CellUpdateFDD_r11, csCallType),
		(ASN_TAG_CLASS_CONTEXT | (10 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_csCallType_14,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"csCallType"
		},
	{ ATF_POINTER, 14, offsetof(struct CellUpdateFDD_r11, hspdschReception_CellFach),
		(ASN_TAG_CLASS_CONTEXT | (11 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_hspdschReception_CellFach_19,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"hspdschReception-CellFach"
		},
	{ ATF_POINTER, 13, offsetof(struct CellUpdateFDD_r11, ueMobilityStateIndicator),
		(ASN_TAG_CLASS_CONTEXT | (12 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_High_MobilityDetected,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"ueMobilityStateIndicator"
		},
	{ ATF_POINTER, 12, offsetof(struct CellUpdateFDD_r11, capabilityChangeIndicator),
		(ASN_TAG_CLASS_CONTEXT | (13 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_capabilityChangeIndicator_22,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"capabilityChangeIndicator"
		},
	{ ATF_POINTER, 11, offsetof(struct CellUpdateFDD_r11, supportOfCommonEDCH),
		(ASN_TAG_CLASS_CONTEXT | (14 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_supportOfCommonEDCH_24,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"supportOfCommonEDCH"
		},
	{ ATF_POINTER, 10, offsetof(struct CellUpdateFDD_r11, supportOfHS_DSCHDRXOperation),
		(ASN_TAG_CLASS_CONTEXT | (15 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_supportOfHS_DSCHDRXOperation_26,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"supportOfHS-DSCHDRXOperation"
		},
	{ ATF_POINTER, 9, offsetof(struct CellUpdateFDD_r11, supportOfMACiis),
		(ASN_TAG_CLASS_CONTEXT | (16 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_supportOfMACiis_28,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"supportOfMACiis"
		},
	{ ATF_POINTER, 8, offsetof(struct CellUpdateFDD_r11, securityRevertStatusIndicator),
		(ASN_TAG_CLASS_CONTEXT | (17 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_securityRevertStatusIndicator_30,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"securityRevertStatusIndicator"
		},
	{ ATF_POINTER, 7, offsetof(struct CellUpdateFDD_r11, spare4),
		(ASN_TAG_CLASS_CONTEXT | (18 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_spare4_33,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"spare4"
		},
	{ ATF_POINTER, 6, offsetof(struct CellUpdateFDD_r11, spare3),
		(ASN_TAG_CLASS_CONTEXT | (19 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_spare3_35,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"spare3"
		},
	{ ATF_POINTER, 5, offsetof(struct CellUpdateFDD_r11, spare2),
		(ASN_TAG_CLASS_CONTEXT | (20 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_spare2_37,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"spare2"
		},
	{ ATF_POINTER, 4, offsetof(struct CellUpdateFDD_r11, spare1),
		(ASN_TAG_CLASS_CONTEXT | (21 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_spare1_39,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"spare1"
		},
	{ ATF_POINTER, 3, offsetof(struct CellUpdateFDD_r11, measuredResultsOnRACH),
		(ASN_TAG_CLASS_CONTEXT | (22 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_MeasuredResultsOnRACHFDD_r11,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"measuredResultsOnRACH"
		},
	{ ATF_POINTER, 2, offsetof(struct CellUpdateFDD_r11, loggedMeasAvailable),
		(ASN_TAG_CLASS_CONTEXT | (23 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_loggedMeasAvailable_42,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"loggedMeasAvailable"
		},
	{ ATF_POINTER, 1, offsetof(struct CellUpdateFDD_r11, loggedANRResultsAvailable),
		(ASN_TAG_CLASS_CONTEXT | (24 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_loggedANRResultsAvailable_44,
		0,	/* Defer constraints checking to the member type */
		0,	/* No PER visible constraints */
		0,
		"loggedANRResultsAvailable"
		},
};
static int asn_MAP_CellUpdateFDD_r11_oms_1[] = { 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24 };
static ber_tlv_tag_t asn_DEF_CellUpdateFDD_r11_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_CellUpdateFDD_r11_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* u-RNTI at 1282 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* startList at 1283 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* am-RLC-ErrorIndicationRb2-3or4 at 1284 */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* am-RLC-ErrorIndicationRb5orAbove at 1285 */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* cellUpdateCause at 1286 */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* failureCause at 1288 */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* rb-timer-indicator at 1289 */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* establishmentCause at 1290 */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* trafficVolumeIndicator at 1291 */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 }, /* reconfigurationStatusIndicator at 1292 */
    { (ASN_TAG_CLASS_CONTEXT | (10 << 2)), 10, 0, 0 }, /* csCallType at 1293 */
    { (ASN_TAG_CLASS_CONTEXT | (11 << 2)), 11, 0, 0 }, /* hspdschReception-CellFach at 1294 */
    { (ASN_TAG_CLASS_CONTEXT | (12 << 2)), 12, 0, 0 }, /* ueMobilityStateIndicator at 1295 */
    { (ASN_TAG_CLASS_CONTEXT | (13 << 2)), 13, 0, 0 }, /* capabilityChangeIndicator at 1296 */
    { (ASN_TAG_CLASS_CONTEXT | (14 << 2)), 14, 0, 0 }, /* supportOfCommonEDCH at 1297 */
    { (ASN_TAG_CLASS_CONTEXT | (15 << 2)), 15, 0, 0 }, /* supportOfHS-DSCHDRXOperation at 1298 */
    { (ASN_TAG_CLASS_CONTEXT | (16 << 2)), 16, 0, 0 }, /* supportOfMACiis at 1299 */
    { (ASN_TAG_CLASS_CONTEXT | (17 << 2)), 17, 0, 0 }, /* securityRevertStatusIndicator at 1300 */
    { (ASN_TAG_CLASS_CONTEXT | (18 << 2)), 18, 0, 0 }, /* spare4 at 1301 */
    { (ASN_TAG_CLASS_CONTEXT | (19 << 2)), 19, 0, 0 }, /* spare3 at 1302 */
    { (ASN_TAG_CLASS_CONTEXT | (20 << 2)), 20, 0, 0 }, /* spare2 at 1303 */
    { (ASN_TAG_CLASS_CONTEXT | (21 << 2)), 21, 0, 0 }, /* spare1 at 1304 */
    { (ASN_TAG_CLASS_CONTEXT | (22 << 2)), 22, 0, 0 }, /* measuredResultsOnRACH at 1306 */
    { (ASN_TAG_CLASS_CONTEXT | (23 << 2)), 23, 0, 0 }, /* loggedMeasAvailable at 1308 */
    { (ASN_TAG_CLASS_CONTEXT | (24 << 2)), 24, 0, 0 } /* loggedANRResultsAvailable at 1309 */
};
static asn_SEQUENCE_specifics_t asn_SPC_CellUpdateFDD_r11_specs_1 = {
	sizeof(struct CellUpdateFDD_r11),
	offsetof(struct CellUpdateFDD_r11, _asn_ctx),
	asn_MAP_CellUpdateFDD_r11_tag2el_1,
	25,	/* Count of tags in the map */
	asn_MAP_CellUpdateFDD_r11_oms_1,	/* Optional members */
	19, 0,	/* Root/Additions */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_CellUpdateFDD_r11 = {
	"CellUpdateFDD-r11",
	"CellUpdateFDD-r11",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	SEQUENCE_decode_uper,
	SEQUENCE_encode_uper,
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_CellUpdateFDD_r11_tags_1,
	sizeof(asn_DEF_CellUpdateFDD_r11_tags_1)
		/sizeof(asn_DEF_CellUpdateFDD_r11_tags_1[0]), /* 1 */
	asn_DEF_CellUpdateFDD_r11_tags_1,	/* Same as above */
	sizeof(asn_DEF_CellUpdateFDD_r11_tags_1)
		/sizeof(asn_DEF_CellUpdateFDD_r11_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_CellUpdateFDD_r11_1,
	25,	/* Elements count */
	&asn_SPC_CellUpdateFDD_r11_specs_1	/* Additional specs */
};

